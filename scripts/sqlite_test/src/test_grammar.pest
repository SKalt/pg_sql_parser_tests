// adapted from https://github.com/codeschool/sqlite-parser/blob/master/test/misc/test-grammar.pegjs
// see also https://github.com/sqlite/sqlite/blob/master/src/tclsqlite.c (maybe?)
// pest grammar reference at https://pest.rs/book/grammars/syntax.html

// running lowest-level -> top-level:.....................................................

// https://tcl.tk/about/language.html ----------------------------------------------------
// Tcl scripts are made up of commands separated by newlines or semicolons.
newline = @{"\r"? ~ "\n"}
CMD_END = _{ newline | ";" }
tcl_script = { newline* ~ cmd+ }

// Each Tcl command consists of one or more words separated by spaces.
WHITESPACE = _{(" " | "\t" | "\\\n" | "\\\r\n")+}

inner_cmd = _{
  // special scraped sqlite3 test-suite commands
    set_sql_cmd
  | execsql_cmd
  | catchsql_cmd
  | do_test_cmd
  | do_execsql_test_cmd
  | do_catchsql_test_cmd
  | do_explain_query_plan_test_cmd
  | do_select_tests_cmd
  | eqp_cmd
  | test_expr_cmd
  | test_expr2_cmd
  | db_eval_cmd
  | single_sql
  | ifcapable_cond
  // general tcl constructs
  | comment
  | set_variable
  | get_variable
  | proc_def
  | for_loop
  | foreach_loop
  | while_loop
  | word+
}

cmd = { inner_cmd ~ CMD_END* }

// Tcl allows you to store values in variables and use the values later in commands.
// The set command is used to write and read variables.
// You can read the value of a variable by invoking set with only a single argument
identifier = @{(alnum | ":" | "-" | "_" | ".")+ }
set_variable = {"set" ~ identifier ~ word }
get_variable = {"set" ~ identifier }


// When a $ appears in a command, Tcl treats the letters and digits following it as a
// variable name, and substitutes the value of the variable in place of the name.
dollar_sub = ${ "$" ~ identifier }

// When a [ appears in a command, Tcl treats everything between it and the matching ] as a nested Tcl command.
// Tcl evaluates the nested command and substitutes its result into the enclosing command in place of the bracketed text.
bracket_sub = {"[" ~ newline* ~ cmd* ~ newline* ~ "]"}
// Double-quotes allow you to specify words that contain spaces.
dquote_escapable_char = { "n" | "r" | "t" | "\\" | "\"" }
escape_char = ${"\\"}
dquote_escaped_char = ${ escape_char ~ dquote_escapable_char }
dquote = {"\""}
not_dqote = _{!dquote ~ ANY}
dquote_word = {
  dquote ~ (
      bracket_sub
    | dollar_sub
    | dquote_escaped_char
    | not_dqote
  )* ~ dquote
}

// Curly braces provide another way of grouping information into words.
// They are different from quotes in that no substitutions are performed on the text between the curly braces
opening_brace = {"{"}
closing_brace = {"}"}
not_closing_brace = _{!closing_brace ~ ANY}
escaped_backslash = {escape_char ~ escape_char}
escaped_opening_brace = { escape_char ~ opening_brace}
escaped_closing_brace = { escape_char ~ closing_brace}
brace_word = {
  opening_brace
  ~ (
        escaped_backslash
      | escaped_opening_brace
      | escaped_closing_brace
      | brace_word
      | not_closing_brace
    )*
  ~ closing_brace
}

word = {
    brace_word
  | dquote_word
  | bracket_sub
  | dollar_sub
  | identifier
  | op
  | (identifier|op|escaped_backslash|escaped_opening_brace|escaped_closing_brace|"'"|"\\"|"("|")"|","|"$")+
}

// special words that should trigger parsing or scraping ///////////////////////
// should recursively parse as tcl:
tcl_body = { &brace_word ~ ("{" ~ newline* ~ tcl_script ~ "}") }
tcl_word = { &word ~ cmd }

// should scrape as candidate sql tests
sql_block = { brace_word }
sql_dquote = { dquote_word }
sql_word = {!dollar_sub ~ !bracket_sub ~ identifier}
sql_candidate = { sql_block | sql_dquote | sql_word }

// recognizable tcl constructs /////////////////////////////////////////////////

// https://tcl.tk/man/tcl8.6/TclCmd/proc.htm
proc_def = { "proc" ~ identifier ~ arg_list ~ tcl_body }
arg_list = { &brace_word ~ ("{" ~ (identifier)* ~ "}") }

// https://tcl.tk/man/tcl8.6/TclCmd/if.htm
if_cond = {
  ("if" ~ word ~ "then"? ~ tcl_body)
  ~ ("elseif" ~ word ~ "then"? ~ tcl_body)*
  ~ ("else" ~ word ~ "then"? ~ tcl_body)?
}
while_loop = { "while" ~ word ~ tcl_body }

// https://tcl.tk/man/tcl8.6/TclCmd/for.htm
for_loop = {
  "for"
  ~ tcl_body // start
  ~ word     // test
  ~ tcl_body // next
  ~ tcl_body // body
}

// https://tcl.tk/man/tcl8.6/TclCmd/foreach.htm
foreach_loop = {
  "foreach" ~ (
      (
        identifier // varname
        ~ word // list
        ~ tcl_body // loop body
      )
    | (
      word // varlist
      ~ word // list
      ~ tcl_body
    )
  )
}

comment = { ("#" ~ (!"\n"+ ~ ANY)* ~ "\n"?)+ }

// special testing procs/blocks ////////////////////////////////////////////////
ifcapable_cond = {"ifcapable" ~ word ~ tcl_body ~ ("else" ~ tcl_body)}
set_sql_cmd = { "set" ~ "sql" ~ (sql_candidate | word) }
// TODO: filter out dquote values w/ substitutions

// see external/sqlite/test/tester.tcl:1420 @ "proc execsql"
execsql_cmd = { "execsql" ~ sql_candidate ~ (word)? }
catchsql_cmd = { "catchsql" ~ sql_candidate ~ (word)? }

// see external/sqlite/test/tester.tcl:762 @ "proc do_test"
do_test_cmd = { "do_test" ~ test_name ~ tcl_body ~ word }

do_execsql_test_cmd = {
  // see external/sqlite/test/tester.tcl:953 @ "proc do_execsql_test"
  ("do_execsql_test"| "do_timed_execsql_test")
  ~ ("-db" ~ word)?
  ~ test_name ~ sql_candidate ~ word?
}

do_catchsql_test_cmd = {
  // see external/sqlite/test/tester.tcl:988 @ "proc do_catchsql_test"
  "do_catchsql_test" ~ test_name ~ sql_candidate ~ word?
}

do_explain_query_plan_test_cmd = {
  // see external/sqlite/test/tester.tcl @ "proc do_eqp_test"
  "do_eqp_test" ~ test_name ~ sql_candidate ~ word
}

selectish_test = {test_name ~ sql_candidate ~ word }
do_select_tests_cmd = {
  // see external/sqlite/test/tester.tcl 
  "do_select_tests"
    ~ test_name
    ~ (&"-" ~ word)*
    ~ (&brace_word ~ ("{" ~ (selectish_test ~ "\n"?)+ ~ "}"))
}

eqp_cmd = {^"eqp" ~ sql_candidate ~ (word)? }


test_expr_cmd = {
  // see external/sqlite/test/expr.test
  "test_expr" ~ test_name
  ~ word // settings
  ~ word // expr
  ~ word // result
  // TODO scrape the foramatted expr, result
}

test_expr2_cmd = {
  // see external/sqlite/test/expr.test
  "test_expr2" ~ test_name ~ word ~ word // expr, result
}

db_eval_cmd = {word ~ "eval" ~ sql_candidate ~ tcl_body?}
single_sql = { ("sql1" | "sql2" | "sql3"| "evalsql" ) ~ sql_candidate}
// /////////////////////////////////////////////////////////////////////////////

main = { SOI ~ tcl_script ~ EOI }
test_name = { word }

// ranges: ---------------------------------------------------------------------
op = {("!" | "&" | "+" | "-"| "/" | "*" | "=" | "?" | "%" | ">" | "<" | "|" | "^")+| ":"}
alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }
alnum = { alpha | digit }